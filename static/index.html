<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FittingFlow - ÊûÅÁÆÄÂ∑•‰ΩúÊµÅ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            gap: 20px;
        }
        
        .panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            width: 100%;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5a6fd6;
        }
        
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        
        .input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .workflow-list {
            list-style: none;
            margin-top: 15px;
        }
        
        .workflow-item {
            padding: 12px;
            border-radius: 8px;
            background: #f8f9fa;
            margin-bottom: 8px;
            cursor: pointer;
        }
        
        .workflow-item:hover {
            background: #e9ecef;
        }
        
        .workflow-item.active {
            background: #667eea;
            color: white;
        }
        
        /* ËäÇÁÇπÂ∫ì */
        .node-template {
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            cursor: grab;
            margin-bottom: 10px;
            user-select: none;
        }
        
        .node-template:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        /* ÁîªÂ∏É */
        .canvas {
            background: #f8f9fa;
            background-image: 
                radial-gradient(circle, #ddd 1px, transparent 1px);
            background-size: 20px 20px;
            border-radius: 8px;
            min-height: 500px;
            position: relative;
            overflow: hidden;
        }
        
        /* Â∑•‰ΩúÊµÅËäÇÁÇπ */
        .workflow-node {
            position: absolute;
            min-width: 150px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            cursor: move;
        }
        
        .workflow-node.selected {
            box-shadow: 0 0 0 3px #667eea, 0 6px 20px rgba(0,0,0,0.25);
        }
        
        .node-header {
            padding: 12px 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .node-title {
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .node-delete {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1rem;
            line-height: 1;
        }
        
        .node-body {
            padding: 12px 15px;
        }
        
        .node-type-label {
            font-size: 0.75rem;
            color: #666;
            text-transform: uppercase;
        }
        
        /* ËøûÊé•ÁÇπ */
        .port {
            position: absolute;
            width: 14px;
            height: 14px;
            background: white;
            border: 3px solid #667eea;
            border-radius: 50%;
            cursor: crosshair;
        }
        
        .port:hover {
            background: #667eea;
        }
        
        .port-input {
            left: -7px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .port-output {
            right: -7px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        /* SVG ËøûÁ∫øÂ±Ç */
        .connections-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .connection-line {
            fill: none;
            stroke: #667eea;
            stroke-width: 3;
            pointer-events: stroke;
            cursor: pointer;
        }
        
        /* Â∑•ÂÖ∑Ê†è */
        .toolbar {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
        }
        
        .toolbar .btn {
            width: auto;
        }
        
        .status-bar {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.85rem;
            max-height: 200px;
            overflow: auto;
            white-space: pre-wrap;
        }
        
        /* Â±ûÊÄßÈù¢Êùø */
        .property-panel {
            display: none;
        }
        
        .property-panel.visible {
            display: block;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîÑ FittingFlow</h1>
            <p>ÊûÅÁÆÄÂ∑•‰ΩúÊµÅÁºñÊéíÁ≥ªÁªü - ÊãñÊãΩÂºèÁºñËæëÂô®</p>
        </div>
        
        <div class="main-content">
            <!-- Â∑¶‰æßÔºöÂ∑•‰ΩúÊµÅÂàóË°® -->
            <div class="panel">
                <div class="section-title">Â∑•‰ΩúÊµÅ</div>
                <input type="text" id="newWorkflowName" class="input" placeholder="ËæìÂÖ•Â∑•‰ΩúÊµÅÂêçÁß∞">
                <button class="btn btn-primary" onclick="createWorkflow()">+ ÂàõÂª∫Â∑•‰ΩúÊµÅ</button>
                <ul class="workflow-list" id="workflowList"></ul>
            </div>
            
            <!-- ‰∏≠Èó¥ÔºöÁîªÂ∏É -->
            <div class="panel">
                <div class="toolbar">
                    <button class="btn btn-primary" onclick="runWorkflow()">‚ñ∂Ô∏è ËøêË°å</button>
                    <button class="btn btn-secondary" onclick="clearCanvas()">üóëÔ∏è Ê∏ÖÁ©∫</button>
                </div>
                <div class="canvas" id="canvas">
                    <svg class="connections-layer" id="connectionsLayer"></svg>
                </div>
                <div class="status-bar" id="statusBar">Â∞±Áª™ - ‰ªéÂè≥‰æßÊãñÊãΩËäÇÁÇπ</div>
            </div>
            
            <!-- Âè≥‰æßÔºöËäÇÁÇπÂ∫ì -->
            <div class="panel">
                <div class="section-title">ËäÇÁÇπÂ∫ì</div>
                <div id="nodeLibrary">
                    <div class="node-template" draggable="true" data-type="start" ondragstart="dragStart(event, 'start')">
                        <div>üöÄ Start</div>
                        <div style="font-size:0.75rem;opacity:0.8;margin-top:4px;">Ëµ∑ÂßãËäÇÁÇπ</div>
                    </div>
                    <div class="node-template" draggable="true" data-type="process" ondragstart="dragStart(event, 'process')">
                        <div>‚öôÔ∏è Process</div>
                        <div style="font-size:0.75rem;opacity:0.8;margin-top:4px;">Â§ÑÁêÜËäÇÁÇπ</div>
                    </div>
                    <div class="node-template" draggable="true" data-type="end" ondragstart="dragStart(event, 'end')">
                        <div>‚úÖ End</div>
                        <div style="font-size:0.75rem;opacity:0.8;margin-top:4px;">ÁªìÊùüËäÇÁÇπ</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // ÁÆÄÂçïÁöÑÁä∂ÊÄÅÁÆ°ÁêÜ
        let currentWorkflow = null;
        let workflows = [];
        let nodes = [];
        let connections = [];
        let selectedNode = null;
        let nodeIdCounter = 0;
        
        let draggingNode = null;
        let dragOffset = { x: 0, y: 0 };
        
        let connecting = false;
        let connectFrom = null;
        
        // ÂàùÂßãÂåñ
        init();
        
        async function init() {
            await fetchWorkflows();
            
            // ÂÖ®Â±Ä‰∫ã‰ª∂
            const canvas = document.getElementById('canvas');
            canvas.ondragover = (e) => {
                e.preventDefault();
                canvas.style.backgroundColor = '#e8f0fe';
            };
            canvas.ondragleave = () => {
                canvas.style.backgroundColor = '';
            };
            canvas.ondrop = drop;
            canvas.onclick = (e) => {
                if (e.target.id === 'canvas' || e.target.id === 'connectionsLayer') {
                    deselectAll();
                }
            };
            
            document.onmousemove = onMouseMove;
            document.onmouseup = onMouseUp;
        }
        
        // ========== Â∑•‰ΩúÊµÅÁÆ°ÁêÜ ==========
        async function fetchWorkflows() {
            try {
                const res = await fetch('/workflows');
                const data = await res.json();
                workflows = data.workflows;
                renderWorkflowList();
            } catch (e) {}
        }
        
        function renderWorkflowList() {
            const list = document.getElementById('workflowList');
            list.innerHTML = workflows.map(wf => `
                <li class="workflow-item ${currentWorkflow === wf.name ? 'active' : ''}" onclick="loadWorkflow('${wf.name}')">
                    ${wf.name}
                </li>
            `).join('');
        }
        
        async function createWorkflow() {
            const name = document.getElementById('newWorkflowName').value.trim();
            if (!name) return;
            
            try {
                await fetch('/workflows', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                document.getElementById('newWorkflowName').value = '';
                await fetchWorkflows();
                loadWorkflow(name);
                setStatus('‚úÖ Â∑•‰ΩúÊµÅÂàõÂª∫ÊàêÂäü');
            } catch (e) {
                setStatus('‚ùå ÂàõÂª∫Â§±Ë¥•');
            }
        }
        
        async function loadWorkflow(name) {
            currentWorkflow = name;
            renderWorkflowList();
            clearCanvas();
            
            try {
                const res = await fetch(`/workflows/${name}`);
                const wf = await res.json();
                
                connections = wf.edges || [];
                
                wf.nodes.forEach((node, i) => {
                    addNode(node.name, node.config?.node_type || 'basic', 50 + i * 200, 100);
                });
                
                renderConnections();
                setStatus(`‚úÖ Â∑≤Âä†ËΩΩ: ${name}`);
            } catch (e) {
                setStatus('‚ùå Âä†ËΩΩÂ§±Ë¥•');
            }
        }
        
        // ========== ÊãñÊãΩËäÇÁÇπ ==========
        function dragStart(e, type) {
            e.dataTransfer.setData('type', type);
        }
        
        function drop(e) {
            e.preventDefault();
            const canvas = document.getElementById('canvas');
            canvas.style.backgroundColor = '';
            
            const type = e.dataTransfer.getData('type');
            if (!type) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - 75;
            const y = e.clientY - rect.top - 30;
            
            const name = `${type}_${++nodeIdCounter}`;
            addNode(name, type, x, y);
            
            if (currentWorkflow) {
                addNodeToBackend(name, type);
            }
            
            setStatus(`‚úÖ Â∑≤Ê∑ªÂä†: ${name}`);
        }
        
        function addNode(name, type, x, y) {
            const node = {
                id: `node_${++nodeIdCounter}`,
                name: name,
                type: type,
                x: x,
                y: y
            };
            nodes.push(node);
            renderOneNode(node);
        }
        
        function renderOneNode(node) {
            const canvas = document.getElementById('canvas');
            
            const el = document.createElement('div');
            el.className = 'workflow-node';
            el.id = node.id;
            el.style.left = node.x + 'px';
            el.style.top = node.y + 'px';
            
            el.innerHTML = `
                <div class="node-header">
                    <span class="node-title">${node.name}</span>
                    <button class="node-delete">√ó</button>
                </div>
                <div class="node-body">
                    <div class="node-type-label">${node.type}</div>
                </div>
                <div class="port port-input"></div>
                <div class="port port-output"></div>
            `;
            
            // Âà†Èô§ÊåâÈíÆ
            el.querySelector('.node-delete').onclick = (e) => {
                e.stopPropagation();
                removeNode(node.id);
            };
            
            // ÈÄâÊã©ËäÇÁÇπ
            el.onclick = (e) => {
                if (e.target.classList.contains('port') || e.target.classList.contains('node-delete')) return;
                e.stopPropagation();
                selectNode(node.id);
            };
            
            // ÊãñÊãΩÁßªÂä®
            el.onmousedown = (e) => {
                if (e.target.classList.contains('port') || e.target.classList.contains('node-delete')) return;
                draggingNode = node;
                const nodeRect = el.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                dragOffset = {
                    x: e.clientX - nodeRect.left,
                    y: e.clientY - nodeRect.top
                };
                selectNode(node.id);
            };
            
            // ËøûÊé•Á´ØÂè£
            el.querySelector('.port-output').onmousedown = (e) => {
                e.stopPropagation();
                connecting = true;
                connectFrom = node;
            };
            
            canvas.appendChild(el);
        }
        
        function selectNode(id) {
            deselectAll();
            selectedNode = nodes.find(n => n.id === id);
            if (selectedNode) {
                document.getElementById(id).classList.add('selected');
            }
        }
        
        function deselectAll() {
            document.querySelectorAll('.workflow-node').forEach(el => el.classList.remove('selected'));
            selectedNode = null;
        }
        
        function removeNode(id) {
            nodes = nodes.filter(n => n.id !== id);
            connections = connections.filter(c => c.source !== id && c.target !== id);
            const el = document.getElementById(id);
            if (el) el.remove();
            renderConnections();
            setStatus('‚úÖ ËäÇÁÇπÂ∑≤Âà†Èô§');
        }
        
        // ========== Èº†Ê†áÁßªÂä® ==========
        function onMouseMove(e) {
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            
            if (draggingNode) {
                draggingNode.x = e.clientX - rect.left - dragOffset.x;
                draggingNode.y = e.clientY - rect.top - dragOffset.y;
                
                const el = document.getElementById(draggingNode.id);
                el.style.left = draggingNode.x + 'px';
                el.style.top = draggingNode.y + 'px';
                
                renderConnections();
            }
            
            if (connecting) {
                const svg = document.getElementById('connectionsLayer');
                let tempLine = svg.querySelector('.temp-line');
                if (!tempLine) {
                    tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tempLine.classList.add('temp-line');
                    tempLine.setAttribute('fill', 'none');
                    tempLine.setAttribute('stroke', '#999');
                    tempLine.setAttribute('stroke-width', '2');
                    tempLine.setAttribute('stroke-dasharray', '5,5');
                    svg.appendChild(tempLine);
                }
                
                const fromEl = document.getElementById(connectFrom.id);
                const fromRect = fromEl.getBoundingClientRect();
                const x1 = fromRect.right - rect.left;
                const y1 = fromRect.top + fromRect.height / 2 - rect.top;
                const x2 = e.clientX - rect.left;
                const y2 = e.clientY - rect.top;
                
                tempLine.setAttribute('d', bezier(x1, y1, x2, y2));
            }
        }
        
        function onMouseUp(e) {
            if (draggingNode) {
                draggingNode = null;
            }
            
            if (connecting) {
                const svg = document.getElementById('connectionsLayer');
                const temp = svg.querySelector('.temp-line');
                if (temp) temp.remove();
                
                const target = e.target;
                if (target.classList.contains('port-input')) {
                    const targetNodeEl = target.closest('.workflow-node');
                    if (targetNodeEl && targetNodeEl.id !== connectFrom.id) {
                        addConnection(connectFrom.id, targetNodeEl.id);
                        if (currentWorkflow) {
                            const fromName = nodes.find(n => n.id === connectFrom.id).name;
                            const toName = nodes.find(n => n.id === targetNodeEl.id).name;
                            connectNodesBackend(fromName, toName);
                        }
                    }
                }
                
                connecting = false;
                connectFrom = null;
            }
        }
        
        // ========== ËøûÁ∫ø ==========
        function addConnection(fromId, toId) {
            const exists = connections.some(c => c.source === fromId && c.target === toId);
            if (exists) return;
            
            connections.push({ source: fromId, target: toId });
            renderConnections();
            setStatus('‚úÖ Â∑≤ËøûÊé•');
        }
        
        function renderConnections() {
            const svg = document.getElementById('connectionsLayer');
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            
            const temp = svg.querySelector('.temp-line');
            svg.innerHTML = '';
            if (temp) svg.appendChild(temp);
            
            connections.forEach((conn, i) => {
                const fromNode = nodes.find(n => n.id === conn.source);
                const toNode = nodes.find(n => n.id === conn.target);
                if (!fromNode || !toNode) return;
                
                const fromEl = document.getElementById(fromNode.id);
                const toEl = document.getElementById(toNode.id);
                if (!fromEl || !toEl) return;
                
                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();
                
                const x1 = fromRect.right - rect.left;
                const y1 = fromRect.top + fromRect.height / 2 - rect.top;
                const x2 = toRect.left - rect.left;
                const y2 = toRect.top + toRect.height / 2 - rect.top;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'connection-line');
                path.setAttribute('d', bezier(x1, y1, x2, y2));
                path.onclick = () => {
                    if (confirm('Âà†Èô§ËøûÁ∫øÔºü')) {
                        connections.splice(i, 1);
                        renderConnections();
                    }
                };
                svg.appendChild(path);
            });
        }
        
        function bezier(x1, y1, x2, y2) {
            const dx = Math.abs(x2 - x1) * 0.5;
            return `M ${x1} ${y1} C ${x1 + dx} ${y1}, ${x2 - dx} ${y2}, ${x2} ${y2}`;
        }
        
        // ========== ÂêéÁ´ØÂêåÊ≠• ==========
        async function addNodeToBackend(name, type) {
            if (!currentWorkflow) return;
            try {
                await fetch(`/workflows/${currentWorkflow}/nodes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        workflow_name: currentWorkflow,
                        node_name: name,
                        node_type: type,
                        config: { node_type: type }
                    })
                });
            } catch (e) {}
        }
        
        async function connectNodesBackend(source, target) {
            if (!currentWorkflow) return;
            try {
                await fetch(`/workflows/${currentWorkflow}/connect`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        workflow_name: currentWorkflow,
                        source_node: source,
                        target_node: target
                    })
                });
            } catch (e) {}
        }
        
        // ========== ÂÖ∂‰ªñ ==========
        async function runWorkflow() {
            if (!currentWorkflow) {
                setStatus('‚ùå ËØ∑ÂÖàÈÄâÊã©Â∑•‰ΩúÊµÅ');
                return;
            }
            
            setStatus('‚è≥ ËøêË°å‰∏≠...');
            try {
                const res = await fetch(`/workflows/${currentWorkflow}/run`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ workflow_name: currentWorkflow, input_data: {} })
                });
                const result = await res.json();
                setStatus('‚úÖ ËøêË°åÂÆåÊàê\n' + JSON.stringify(result, null, 2));
            } catch (e) {
                setStatus('‚ùå ËøêË°åÂ§±Ë¥•');
            }
        }
        
        function clearCanvas() {
            nodes = [];
            connections = [];
            selectedNode = null;
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = '<svg class="connections-layer" id="connectionsLayer"></svg>';
        }
        
        function setStatus(msg) {
            document.getElementById('statusBar').textContent = msg;
        }
    </script>
</body>
</html>
